package com.andrews.estructuras;

import com.andrews.escenario.HileraB;
import com.andrews.sprites.Enemigo;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;

public class ListaDoble<T> extends Lista {

	private NodoDoble<T> primero;
	private int tamaño;
	
	public ListaDoble(){
		this.primero = null;
	}
	
	public boolean isEmpty() {
		if (this.primero == null) {
			return true;
		}
		else {
			return false;		
		}
	}
	
	public void agregarAlInicio(T dato) {
		NodoDoble<T> nuevo = new NodoDoble<T>();
		nuevo.setDato(dato);
		if(this.primero == null) {
			this.primero = nuevo;
			this.tamaño ++;
		}
		else {
			nuevo.setSiguiente(this.primero);
			this.primero.setAnterior(nuevo);
			this.primero = nuevo;
			this.tamaño ++;
		}
	}
	
	public void agregarAlFinal(T dato) {
		NodoDoble<T> nuevo = new NodoDoble<T>();
		nuevo.setDato(dato);
		if(this.primero == null) {
			this.primero = nuevo;
		}
		else {
			NodoDoble<T> aux = primero;
			while(aux.getSiguiente() != null) {
				aux = aux.getSiguiente();
			}
			aux.setSiguiente(nuevo);
			nuevo.setAnterior(aux);
			this.tamaño ++;
		}
	}
	
	public int getTamaño() {
		return this.tamaño;
	}
	
    public T getDato(int pos) {
    	NodoDoble<T> aux = this.primero;
    	int cont = 0;
    	while(cont != pos) {
    		aux = aux.getSiguiente();
    		cont ++;
    	}
    	return aux.getDato();
    }
    
    public NodoDoble<T> getNodo(int pos){
    	if(pos == 0) {
    		return this.primero;
   		}
   		else {
   			NodoDoble<T> aux = primero;
   			for(int i = 0; i < pos-1; i++) {    				
   				aux = aux.getSiguiente();
    		}
    		return aux;
    	}
    }
    
    public void insertarPos(int pos, T dato) {
    	if(pos>= 0 && pos<=this.tamaño) {
    		NodoDoble<T> nuevo = new NodoDoble<T>();
    		nuevo.setDato(dato);
    		if(pos == 0) {
    			this.agregarAlInicio(dato);
    		}
    		else {
    			if(pos == tamaño) {
    				this.agregarAlFinal(dato);
    			}
    			else {
    				NodoDoble<T> aux = this.primero;
    				for(int i = 0; i <(pos - 1); i++) {
    					aux = aux.getSiguiente();
    				}
    				NodoDoble<T> siguiente = aux.getSiguiente();
    				aux.setSiguiente(nuevo);
    				nuevo.setSiguiente(siguiente);
    				nuevo.setAnterior(aux);
    				siguiente.setAnterior(nuevo);
    			}
    		}
    	this.tamaño ++;
    	}
    }
    
    public void eliminarPos(int pos, ListaDoble<Enemigo> lista) {
    	if(pos>=0 && pos < this.tamaño) {
    		if (pos == 0) {
    			this.primero = primero.getSiguiente();
    		}
    		else {
    			NodoDoble<T> aux = primero;
    			for(int i = 0; i < pos-1; i++) {
    				aux = aux.getSiguiente();
    			}
    			NodoDoble<T> siguiente = aux.getSiguiente();
    			this.mover(siguiente, lista);
    			aux.setSiguiente(siguiente.getSiguiente());
    		}
    		this.tamaño --;
    	}
    }
    
    public void mover(NodoDoble<T> nodo, ListaDoble<Enemigo> lista) {
    	NodoDoble<T> aux = this.primero;
    	int cont = 0;
    	while(aux!=nodo) {
    		lista.getDato(cont).getBordes().x += 25;
    		aux = aux.getSiguiente();
    		cont ++;
    	}
    	while(cont < lista.tamaño) {
    		lista.getDato(cont).getBordes().x -= 25;
    		cont ++;
    	}
    }
   
    public void reemplazar(int pos, NodoDoble<T> reemplazo) {
    	NodoDoble<T> pivote = new NodoDoble<T>();
    	for(int i = 0; i <= pos; i ++) {
    		if (i == pos) {
    			reemplazo.setAnterior(pivote.getAnterior());
    	    	reemplazo.setSiguiente(pivote.getSiguiente());
    	    	pivote.getAnterior().setSiguiente(reemplazo);
    	    	pivote.getSiguiente().setAnterior(reemplazo);
    		}
    		pivote = pivote.getSiguiente();
    	}
    	
    }
    
}
